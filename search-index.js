var searchIndex = {};
searchIndex["icns"] = {"doc":"A library for encoding/decoding Apple Icon Image (.icns) files.","items":[[3,"IconElement","icns","One data block in an ICNS file.  Depending on the resource type, this may\nrepresent an icon, or part of an icon (such as an alpha mask, or color\ndata without the mask).",null,null],[12,"ostype","","The OSType for this element (e.g. `it32` or `t8mk`).",0,null],[12,"data","","The raw data payload for this element.",0,null],[3,"IconFamily","","A set of icons stored in a single ICNS file.",null,null],[12,"elements","","The icon elements stored in the ICNS file.",1,null],[3,"OSType","","A Macintosh OSType (also known as a ResType), used in ICNS files to\nidentify the type of each icon element.",null,null],[3,"Image","","A decoded icon image.",null,null],[4,"Encoding","","Methods of encoding an image within an icon element.",null,null],[13,"Mask8","","Icon element data payload is an uncompressed 8-bit alpha mask.",2,null],[13,"RLE24","","Icon element data payload is an RLE-compressed 24-bit RGB image.",2,null],[13,"JP2PNG","","Icon element data payload is a JPEG 2000 or PNG file.",2,null],[4,"IconType","","Types of icon elements that can be decoded as images or masks.",null,null],[13,"RGB24_16x16","","16x16 24-bit icon (without alpha).",3,null],[13,"Mask8_16x16","","16x16 8-bit alpha mask.",3,null],[13,"RGB24_32x32","","32x32 24-bit icon (without alpha).",3,null],[13,"Mask8_32x32","","32x32 8-bit alpha mask.",3,null],[13,"RGB24_48x48","","48x48 24-bit icon (without alpha).",3,null],[13,"Mask8_48x48","","48x48 8-bit alpha mask.",3,null],[13,"RGB24_128x128","","128x128 24-bit icon (without alpha).",3,null],[13,"Mask8_128x128","","128x128 8-bit alpha mask.",3,null],[13,"RGBA32_16x16","","16x16 32-bit icon.",3,null],[13,"RGBA32_16x16_2x","","16x16 32-bit icon at 2x &quot;retina&quot; density (so, 32 by 32 pixels).",3,null],[13,"RGBA32_32x32","","32x32 32-bit icon.",3,null],[13,"RGBA32_32x32_2x","","32x32 32-bit icon at 2x &quot;retina&quot; density (so, 64 by 64 pixels).",3,null],[13,"RGBA32_64x64","","64x64 32-bit icon.  (For whatever reason, the ICNS format has no\ncorresponding type for a 64x64 icon at 2x &quot;retina&quot; density.)",3,null],[13,"RGBA32_128x128","","128x128 32-bit icon.",3,null],[13,"RGBA32_128x128_2x","","128x128 32-bit icon at 2x &quot;retina&quot; density (so, 256 by 256 pixels).",3,null],[13,"RGBA32_256x256","","256x256 32-bit icon.",3,null],[13,"RGBA32_256x256_2x","","256x256 32-bit icon at 2x &quot;retina&quot; density (so, 512 by 512 pixels).",3,null],[13,"RGBA32_512x512","","512x512 32-bit icon.",3,null],[13,"RGBA32_512x512_2x","","512x512 32-bit icon at 2x &quot;retina&quot; density (so, 1024 by 1024 pixels).",3,null],[4,"PixelFormat","","Formats for storing pixel data in an image.",null,null],[13,"RGBA","","32-bit color with alpha channel.  Each pixel is four bytes, with red\nfirst and alpha last.",4,null],[13,"RGB","","24-bit color with no alpha.  Each pixel is three bytes, with red\nfirst and blue last.",4,null],[13,"GrayAlpha","","16-bit grayscale-with-alpha.  Each pixel is two bytes, with the\ngrayscale value first and alpha second.",4,null],[13,"Gray","","8-bit grayscale with no alpha.  Each pixel is one byte (0=black,\n255=white).",4,null],[13,"Alpha","","8-bit alpha mask with no color.  Each pixel is one byte (0=transparent,\n255=opaque).",4,null],[11,"new","","Creates an icon element with the given OSType and data payload.",0,{"inputs":[{"name":"ostype"},{"name":"vec"}],"output":{"name":"iconelement"}}],[11,"encode_image_with_type","","Creates an icon element that encodes the given image as the given icon\ntype.  Image color channels that aren&#39;t relevant to the specified icon\ntype will be ignored (e.g. if the icon type is a mask, then only the\nalpha channel of the image will be used).  Returns an error if the\nimage dimensions don&#39;t match the icon type.",0,{"inputs":[{"name":"image"},{"name":"icontype"}],"output":{"name":"result"}}],[11,"decode_image","","Decodes the icon element into an image.  Returns an error if this\nelement does not represent an icon type supported by this library, or\nif the data is malformed.",0,{"inputs":[{"name":"iconelement"}],"output":{"name":"result"}}],[11,"decode_image_with_mask","","Decodes this element, together with a separate mask element, into a\nsingle image with alpha channel.  Returns an error if this element does\nnot represent an icon type supported by this library, or if the given\nmask element does not represent the correct mask type for this element,\nor if any of the data is malformed.",0,{"inputs":[{"name":"iconelement"},{"name":"iconelement"}],"output":{"name":"result"}}],[11,"icon_type","","Returns the type of icon encoded by this element, or `None` if this\nelement does not encode a supported icon type.",0,{"inputs":[{"name":"iconelement"}],"output":{"name":"option"}}],[11,"read","","Reads an icon element from within an ICNS file.",0,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"write","","Writes the icon element to within an ICNS file.",0,{"inputs":[{"name":"iconelement"},{"name":"w"}],"output":{"name":"result"}}],[11,"total_length","","Returns the encoded length of the element, in bytes, including the\nlength of the header.",0,{"inputs":[{"name":"iconelement"}],"output":{"name":"u32"}}],[11,"new","","Creates a new, empty icon family.",1,{"inputs":[],"output":{"name":"iconfamily"}}],[11,"add_icon","","Encodes the image into the family, automatically choosing an\nappropriate icon type based on the dimensions of the image.  Returns\nan error if there is no supported icon type matching the image\ndimensions.",1,{"inputs":[{"name":"iconfamily"},{"name":"image"}],"output":{"name":"result"}}],[11,"add_icon_with_type","","Encodes the image into the family using the given icon type.  If the\nselected type has an associated mask type, the image mask will also be\nadded to the family.  Returns an error if the image has the wrong\ndimensions for the selected type.",1,{"inputs":[{"name":"iconfamily"},{"name":"image"},{"name":"icontype"}],"output":{"name":"result"}}],[11,"available_icons","","Returns a list of all (non-mask) icon types for which the icon family\ncontains the necessary element(s) for a complete icon image (including\nalpha channel).  These icon types can be passed to the\n[`get_icon_with_type`](#method.get_icon_with_type) method to decode the\nicons.",1,{"inputs":[{"name":"iconfamily"}],"output":{"name":"vec"}}],[11,"get_icon_with_type","","Decodes an image from the family with the given icon type.  If the\nselected type has an associated mask type, the two elements will\ndecoded together into a single image.  Returns an error if the\nelement(s) for the selected type are not present in the icon family, or\nthe if the encoded data is malformed.",1,{"inputs":[{"name":"iconfamily"},{"name":"icontype"}],"output":{"name":"result"}}],[11,"read","","Reads an icon family from an ICNS file.",1,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"write","","Writes the icon family to an ICNS file.",1,{"inputs":[{"name":"iconfamily"},{"name":"w"}],"output":{"name":"result"}}],[11,"total_length","","Returns the encoded length of the file, in bytes, including the\nlength of the header.",1,{"inputs":[{"name":"iconfamily"}],"output":{"name":"u32"}}],[11,"eq","","",3,{"inputs":[{"name":"icontype"},{"name":"icontype"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"icontype"},{"name":"icontype"}],"output":{"name":"bool"}}],[11,"hash","","",3,null],[11,"fmt","","",3,{"inputs":[{"name":"icontype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"icontype"}],"output":{"name":"icontype"}}],[11,"from_ostype","","Get the icon type associated with the given OSType, if any.",3,{"inputs":[{"name":"ostype"}],"output":{"name":"option"}}],[11,"ostype","","Get the OSType that represents this icon type.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"ostype"}}],[11,"is_mask","","Returns true if this is icon type is a mask for some other icon type.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"bool"}}],[11,"mask_type","","If this icon type has an associated mask type, returns that mask type;\nif this is a mask icon type, or a non-mask icon type that has no\nassociated mask type, returns `None`.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"option"}}],[11,"pixel_width","","Returns the pixel data width of this icon type.  Normally this is the\nsame as the screen width, but for 2x &quot;retina&quot; density icons, this will\nbe twice that value.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"u32"}}],[11,"pixel_height","","Returns the pixel data height of this icon type.  Normally this is the\nsame as the screen height, but for 2x &quot;retina&quot; density icons, this will\nbe twice that value.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"u32"}}],[11,"pixel_density","","Returns the pixel density for this icon type -- that is, 2 for 2x\n&quot;retina&quot; density icons, or 1 for other icon types.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"u32"}}],[11,"screen_width","","Returns the screen width of this icon type.  Normally this is the same\nas the pixel width, but for 2x &quot;retina&quot; density icons, this will be\nhalf that value.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"u32"}}],[11,"screen_height","","Returns the screen height of this icon type.  Normally this is the same\nas the pixel height, but for 2x &quot;retina&quot; density icons, this will be\nhalf that value.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"u32"}}],[11,"encoding","","Returns the encoding used within an ICNS file for this icon type.",3,{"inputs":[{"name":"icontype"}],"output":{"name":"encoding"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"option"}}],[11,"lt","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"le","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"gt","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"ge","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"ostype"},{"name":"ostype"}],"output":{"name":"ordering"}}],[11,"hash","","",5,null],[11,"fmt","","",5,{"inputs":[{"name":"ostype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"ostype"}],"output":{"name":"ostype"}}],[11,"fmt","","",5,{"inputs":[{"name":"ostype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_str","","",5,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"encoding"},{"name":"encoding"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"encoding"},{"name":"encoding"}],"output":{"name":"bool"}}],[11,"hash","","",2,null],[11,"fmt","","",2,{"inputs":[{"name":"encoding"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"encoding"}],"output":{"name":"encoding"}}],[11,"clone","","",6,{"inputs":[{"name":"image"}],"output":{"name":"image"}}],[11,"new","","Creates a new image with all pixel data set to zero.",6,{"inputs":[{"name":"pixelformat"},{"name":"u32"},{"name":"u32"}],"output":{"name":"image"}}],[11,"pixel_format","","Returns the format in which this image&#39;s pixel data is stored.",6,{"inputs":[{"name":"image"}],"output":{"name":"pixelformat"}}],[11,"width","","Returns the width of the image, in pixels.",6,{"inputs":[{"name":"image"}],"output":{"name":"u32"}}],[11,"height","","Returns the height of the image, in pixels.",6,{"inputs":[{"name":"image"}],"output":{"name":"u32"}}],[11,"data","","Returns a reference to the image&#39;s pixel data.",6,null],[11,"data_mut","","Returns a mutable reference to the image&#39;s pixel data.",6,null],[11,"into_data","","Consumes the image, returning the pixel data without cloning it.",6,{"inputs":[{"name":"image"}],"output":{"name":"box"}}],[11,"convert_to","","Creates a copy of this image by converting to the specified pixel\nformat.  This operation always succeeds, but may lose information (e.g.\nconverting from RGBA to RGB will silently drop the alpha channel).  If\nthe source image is already in the requested format, this is equivalant\nto simply calling `clone()`.",6,{"inputs":[{"name":"image"},{"name":"pixelformat"}],"output":{"name":"image"}}],[11,"read_png","","Reads an image from a PNG file.",6,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"write_png","","Writes the image to a PNG file.",6,{"inputs":[{"name":"image"},{"name":"w"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"pixelformat"},{"name":"pixelformat"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"pixelformat"},{"name":"pixelformat"}],"output":{"name":"bool"}}],[11,"hash","","",4,null],[11,"fmt","","",4,{"inputs":[{"name":"pixelformat"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"pixelformat"}],"output":{"name":"pixelformat"}}],[11,"bits_per_pixel","","Returns the number of bits needed to store a single pixel in this\nformat.",4,{"inputs":[{"name":"pixelformat"}],"output":{"name":"u32"}}]],"paths":[[3,"IconElement"],[3,"IconFamily"],[4,"Encoding"],[4,"IconType"],[4,"PixelFormat"],[3,"OSType"],[3,"Image"]]};
initSearch(searchIndex);
